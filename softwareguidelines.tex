\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{hyperref}{}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{natbib}
\usepackage[margin=3cm]{geometry}
\usepackage{parskip}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}
\renewcommand{\familydefault}{\sfdefault}


% customize section
\titleformat{\section}%
{\Large\bfseries}% format
{\llap{% label
    \thesection\hskip 9pt}}%
{0pt}% horizontal sep
{}% before

% customize subsection
\titleformat{\subsection}%
{\bfseries}% format
{\llap{% label
    \thesubsection\hskip 9pt}}%
{0pt}% horizontal sep
{}% before

\newenvironment{notice}{
\begin{center}
    \begin{tabular}[h!]{|p{0.8\textwidth}|}
    \hline
    {\bf IMPORTANT NOTICE!}\\\hline}
{   \\\hline
    \end{tabular}
\end{center}}

\newcommand{\indicator}[1]{\subsubsection*{\underline{#1}}}

\begin{document}

\title{Guidelines for Software Quality}
\subtitle{CLARIAH Task 54.100} 
\author{Maarten van Gompel \\ Centre for Language \& Speech Technology \\ Radboud University Nijmegen }

\maketitle

\begin{notice} 
This is a draft document, everything in it is to be considered a
proposal only. The guidelines have not been reviewed nor adopted yet.
\end{notice}

\tableofcontents

\section{Introduction}

CLARIAH aims to deliver a digital research infrastructure made explicitly
accessible for researchers from the humanities. This makes the development of advanced ICT
tools a core activity within CLARIAH. To be able assess the
quality of the research infrastructure as a whole, we need to be able to assess
the quality of its individual software and data components. If we can establish
a common set of software guidelines, we may more readily identify weaker
components of the software infrastructure and work on their improvement.
Assessing software or data quality, however, is not a trivial matter. 

Whenever we refer to \emph{software}, we intend the term in a broad sense and
encompassing all of the following aspects:
\begin{itemize}
    \item source code
    \item binary executables
    \item user interfaces (including application programming interfaces (APIs) and web APIs)
    \item associated essential data
    \item documentation (including tutorials, screencasts)
    \item support infrastructure (version control, build systems, issue trackers)
\end{itemize}

These guidelines for software quality consists of various assessment
criteria, such as ``Documentation'' and ``Installability''. Each criterion in turn
consists of assessment indicators formulated as a series of questions. This
makes them directly applicable as an instrument for software quality
assessment. 

These guidelines target developers, managers and users of software.
Developers will be more aware of the targets to meet, and able to identify and
remedy weak areas. Managers and users will be able to assess whether software
is of sufficient enough quality for their purposes. Although we intend to
formulate the questions as plainly as possible, a certain degree of technical
expertise is demanded of all of these in order to attain a successful
assessment.

Each question, can be be answered with ``yes'', ``no'' or ``not applicable'' in
case the guideline has no relevance for the software. The correct answer is
always the affirmative. This will lead to measurable quality levels. Full
compliance with the guidelines is achieved when all questions are answered
affirmatively.  In practise, however, this is not realistic to happen.
Evaluators will need to determine for themselves what compliance level, per
category, constitutes an acceptable passing threshold.

The criteria we yield are adopted from to large extent from the
\emph{Criteria-based Software Evaluation Guide} \citep{SSIGUIDE} by the Software
Sustainability Institute (SSI). Their work, in turn, is modelled after
\emph{ISO/IEC 9126-1 Software Engineering - Product Quality} \citep{ISO9126}.
The Software Sustainability Institute\citep{SSIGENERAL} is an academic institute
explicitly geared towards researchers and software developers in science, the
criteria they drafted are therefore deemed to form a very relevant basis for
research projects such as CLARIAH. Software quality assessment will have a
large generic component regardless of the context of the larger project. A
large portion of these guidelines is therefore applicable the broader contexts
of software quality in academics, software quality for open source projects, and
software quality in general.

The criteria used by the SSI are shown in Table~\ref{tab:criteria}.

\begin{table}[hbt]
\begin{tabular}{l|l}
\hline
\multicolumn{2}{c}{\textbf{Usability}} \\
\hline
Understandability & Is the software easily understood? \\ 
Documentation & Comprehensive well-structured documentation? \\
Buildability  & Straightforward to build from source on a supported system? \\
Installability  & Straightforward to install and deploy on a supported system? \\
Learnability & Easy/intuitive to learn how to use its functions? \\
\hline
\multicolumn{2}{c}{\textbf{Sustainability \& Manageability}} \\
\hline
Identity & Project/software identity is clear and unique? \\
Copyright & Easy to see who owns the project/software? \\
Licencing & Adoption of appropriate licence? \\
Governance & Easy to understand how the project is run and the development managed? \\
Community & Evidence of current/future community? \\
Accessibility & Evidence of good facilities to obtain versions of the software? \\
Testability & Easy to verify if the software functions correctly? \\
Portability & Usable on multiple platforms? \\
Supportability & Evidence of current/future developer support? \\
Analysability & Easy to understand at the source-code level? \\
Changeability & Easy to modify and contribute changes? \\
Evolvability & Evidence of current/future development? \\
Interoperability & Interoperable with other required/related software? \\
\end{tabular}
\caption{Software quality criteria according to the SSI \citep{SSIGUIDE}. (with some minor paraphrasing)}
\label{tab:criteria}
\end{table}

We adopt this scheme with the following changes:

\begin{itemize}
\item Copyright \& Licensing are merged.
\item Governance is omitted entirely. %(proycon) we may want to resurrect it later in a more CLARIAH-specific sense?
\item Evolvability was merged into Changeability.
\item Security \& Privacy criterion is added to Sustainability \& Manageability
\item Performance criterion was added to Usability.
\item Reusability criterion was added to Sustainability \& Manageability: To what extend is the software reusable?
\item The Interoperability criterion is split into a generic section and a CLARIAH-specific section. The latter provides indicators to assess
whether the software complies to requirements for integration into the CLARIAH infrastructure.
\end{itemize}

The next sections lay out all criteria with the individual assessment
indicators. The individual indicators are inspired on the SSI guidelines but
are not directly copied. Our indicators are generally more condensed and may
group issues that were expressed as multiple indicators in the SSI guide.
Various indicators have also been added that did not exist in the SSI guide,
and there were many various indicators we found too specific to use.

Each indicator carries an ID code for easy reference. Cross-references will be
made whenever there is a relationship between indicators.

\section{Quality Assessment Criteria - Usability}

\subsection{Understandability}

\indicator{U1 -- Is it clear what the software does?}

Software must be accompanied be a clear and concise high-level description,
describing what exactly it does. Both the \texttt{README} file that ships with
the software (see IS7) as well as the project website (see ID2) should contain
this information. 

\indicator{U2 -- Is it clear for whom the software is intended?}

It should be clear who are the intended users for the software. Software is
usually not appropriate for all audiences. Gearing software at multiple
audiences however, through for instance offering multiple interfaces (command
line interface (CLI) , graphical user interface (GUI), web-user interface
(WUI), webservice) is good practise. References to projects already using the
software are recommended (see also CM1).

\indicator{U3 -- Is it clear how the software works?}

There should be a high-level description explaining how the software
accomplishes its task. Links to publications are recommended. Also, a schema
offering an architectural overview is suggested where appropriate. 

\indicator{U4 -- Is the software motivated?}

There should be a written motivation for why the software does things the way
it does and why it was designed in the first place. It should be clear what
problems are solved by it. Links to publications and comparisons to similar
software are strongly recommended.

\subsection{Documentation}

When we refer to documentation, we refer to the set of all documentation
available for the software. This may consists of different types of
documentation for different audiences, and may include published papers.

\indicator{D1 -- Is there documentation?}

All software should be properly documented. Software without any documentation
is as good as useless. At the very least, documentation at a minimum level
must be available. 

\indicator{D2 -- Is the documentation accessible?}

Documentation must be publicly accessible and in an acceptable standard format
such as HTML or PDF.

\indicator{D3 -- Is the documentation clear?}

Documentation should be written in clear language and clearly describe the software.
Step-by-step and task-oriented instructions are recommended.

\indicator{D4 -- Is the documentation complete?}

Documentation should cover the entire software, including advanced features.

\indicator{D5 -- Is the documentation accurate?}

Documentation should describe the advertised version and not be out-of-date
with the latest release. Example should be in line with how the tool looks and
behaves.

\indicator{D6 -- Does the documentation provide a high-level overview of the software?}

Documentation should offer a high-level overview of the software, rather
than immediately dive into the details.

\indicator{D7 -- Are all the necessary audiences addressed, at their appropriate levels?}

Different groups of users require different documentation. Developers require
APIs if the software is a library (see L4), end-users require a walkthrough of the GUI
if the software has one. A different level of expertise may be expected of
different user groups, the documentation should assume the appropriate level.

\indicator{D8 -- Does the documentation make use of adequate examples?}

Documentation should contain examples appropriate for the interface that is
described. Command-line interfaces should see examples of invocation and input
and output. Graphical user interfaces should be illustrated through screenshots or
screencasts. API references should contain source code examples of usage.

\indicator{D9 -- Is there adequate troubleshooting information?}

Documentation should include information on troubleshooting, i.e.\ a
specification of possible error messages and explanation for resolution.

\indicator{D10 -- Is the documentation available from the project website?}

Documentation must be clearly linked from the project website.

\indicator{D11 -- Is the documentation under version control?}

The sources for documentation must be under version control like the source
code, preferably alongside the code itself.

\subsection{Learnability}

This category partially overlaps with the documentation criterion, but explicitly
focusses on how straightforward it is to learn to use the software.

\indicator{L1 -- Is there a getting started guide?}

A getting started guide outlines how to quickly get started with the software
using a basic example.

\indicator{L2 -- Are there instructions for basic use cases?}

Instructions should be provided for at least basic use cases, and ideally for
all possible use cases.

\indicator{L3 -- Does the interface provide a help reference?}

Help options should be provided by the interface. Command line interfaces must
have a -h/--help pair describing usage and all options. GUIs should use tooltips/hints to clarify
their widgets (or through whatever convention is customary for the
platform/ecosystem). Alternatively, they can provide a help option referring to
the documentation.

\indicator{L4 -- Is there API documentation for developers?}

If the software is a programming library. API documentation must be provided.
If the software is a webservice, a specification of the web API must be provided.

\indicator{L5 -- If the software is configurable, are the configuration
options clearly explained?}


\subsection{Buildability}

Buildability applies to all software written in languages that compile to
either native machine code or any intermediate byte code to be interpreted by a VM.
This is contrasted to software that is interpreted at run-time from source
code. This section is therefore applicable only to languages such as C, C++,
Java, Pascal, Haskell, Scala, Rust, Cython but not to scripting language such
as Python, Ruby, Perl, Go.  Note that buildability does not include
installation, packaging, or deployment.

\indicator{B1 -- Are there good instructions for building/compiling the software?}

Build/compilation instruction should be available and clear enough. They should
be distributed alongside the software's source distribution (as part of an
\texttt{INSTALL} file or \texttt{README}), and/or be addressed in the documentation. If the
source distribution is the primary means of distribution, then build
instructions should be prominently displayed on the project website as well.

\indicator{B2 -- Is an established automated build system used?}

Established build systems should be used. For example the GNU Build
System\footnote{also known as the autotools} or CMake for C/C++ (this is
preferred over a static Makefile); or Ant or Maven for Java. 

Solutions that are not tied to a single IDE are always preferred.

\indicator{B3 -- Are all dependencies listed and available?}
(related to IS2)

All required or optional dependencies should be listed, including those by
third parties (with references to their websites). If the build system supports
automatically obtaining dependencies, then this is a preferred solution. If the
platform has a package manager that can install these dependencies, then add
instructions (i.e. package names) to accomplish this.

Moreover, all listed dependencies should be available, unobtainable software
can not be used as a dependency. Higher-order dependencies need not be listed.

\indicator{B4 -- Are there tests to verify the build has succeeded?}

A build process should terminate with a testing stage that verifies its success.

\subsection{Installability}

Installability concerns the deployment of software on the target platform, also
including configuration of the software to the user's needs.

\indicator{IS1 -- Are there easily accessible installation instructions?}

All software must come with installation instructions. Those instructions should
be easily accessible and presented on the project website as well as shipped
with the software in the README or INSTALL file (see also IS7). Build and installation
instructions can be combined if the software is published as a source
distribution.

\indicator{IS2 -- Are all dependencies listed and available?}
(related to B3)

All required or optional dependencies should be listed, including those by
third parties (with references to their websites). If the installation
procedure supports automatically obtaining dependencies, then this is a
preferred solution (see also IS3). If the platform has a package manager that
can install these dependencies, then add instructions (i.e. package names) to
accomplish this.

Moreover, all listed dependencies should be available, unobtainable software
can not be used as a dependency. Higher-order dependencies need not be listed.

\indicator{IS3 -- Does the installation procedure comply to best practises
in the ecosystem around the programming language?}

The ecosystem surrounding programming languages may come with standard
procedures for installation. Software should comply to these rather than use
ad-hoc mechanisms. If the ecosystem has facilities for dependency management
(automatic download of dependencies), these should be used.

\begin{itemize}
 \item Python software should have a \texttt{setup.py} based on Distutils,
     Setuptools, or their relatives.
 \item Installation of C/C++ software is generally an extension of the build
     process, often culminating in a \texttt{make install}.
 \item TODO: Java, R ?
\end{itemize}

\indicator{IS4 -- Is the software packaged according to standards for the target platform?}

If the software has a well-defined target platform and is intended for adoption
by a wider audience, it is recommended to package it in the appropriate form.
This may however conflict with IS3, be rendered obsolete by IS3, or render IS3
obsolete. The decision form of installation takes takes precendence should be
made on an individual basis, considering the nature and audience of the
software.

\begin{itemize}
    \item Linux/BSD/Unix -- Distributions generally have their own package manager
    \begin{itemize}
        \item Arch Linux: Use the Arch User Repository (AUR)
        \item Debian/Ubuntu (and other derivates): Use Debian Packages (deb)
        \item RedHat/CentOS/Fedora (and other derivates): Use Red Hat Packages (rpm)
    \end{itemize}
    \item Mac OS X: Use PKG or DMG for traditional Mac applications intended for end-users; for the more Unix-style
        software, use a system such as Homebrew or MacPorts
    \item Android: Use Android Application Packages (APK)
    \item iOS: (TODO) 
    \item Windows: (TODO) 
\end{itemize}

It is not always time and cost effective to package the software, especially not
when there are multiple target platforms. 

\indicator{IS5 -- Is the software package properly structured?}

The contents of the package should be properly organised in sub-directories
(for documentation, headers, source, etc..). Conventions may differ between
programming languages.

If software is distributed as a plain archive (tar.gz, tar.bz2, zip or otherwise),
it must create a single directory when unpacked rather than spread its contents
over the current working directory.

\indicator{IS6 -- Is the software properly structured when installed?}

When the software is installed, it should adhere to file placement standards set
by the target platform. On Unix-like operating systems (excluding Mac OS X), the Filesystem
Hierarchy Standard\footnote{\url{http://refspecs.linuxfoundation.org/fhs.shtml}} (FHS) should be followed.

\indicator{IS7 -- The software must include a README}

The \texttt{README} file must contain links to the project website, as well as
licence and copyright information. The README should be either plain-text or
preferably in an unobtrusive mark-up format such as Markdown or ReStructuredText.

If a public version control platform such as GitHub is used (see AC2), the
README will usually be visualised on the repository page.

\indicator{IS8 -- Are there facilities to uninstall the software?}

This is usually trivial when the software complies to IS4 and/or IS3, or if the
software installation is self-contained in a single directory. In all other
instances, proper uninstallation facilities should be in explicitly implemented.

\indicator{IS9 -- Are the system requirements such as target platform clearly advertised?}

The project website must be clearly state what target platform(s) the software is expected to run.
System requirements in terms of computing resources must be stated if the software employs more than insignificant resources (see PF2).
(related also to B3 and IS2)

\subsection{Performance}

\indicator{PF1 -- Does the software perform its function(s) as efficiently as can be expected?}

Software should employ efficient algorithms to perform its task. Obvious performance bottlenecks \emph{may} be an indication of sub-optimal design choices.
(Consider also U4)

\indicator{PF2 -- Does the software make a reasonable demand on computing resources?}

Software should not place an unreasonable demand on computing resource (memory,
CPU time). Overuse of resources \emph{may} be an indication of sub-optimal
design choices.  If the software does make high demand on particular resources,
then this should be clearly advertised and explained (in the documentation for
instance) and also stated as part of the system requirements.

Be aware that there is often a trade-off between speed and memory usage. The
developer of the decision must make an appropriate decision favouring one or the other
given the task at hand. 

\indicator{PF3 -- Does the software make efficient use of available resources?}

Software should make use of available resources if is helps getting the job
done faster. For instance, if multiple CPU cores are available and the task at hand
would benefit significantly from parallelisation, then the implementation should be
multithreaded to make use of said cores.

\indicator{PF4 -- Is the interface responsive?}

GUIs and WUIs should be responsive and deliver clear feedback when the user is
to await the completion of the task. GUIs and WUIs should use asynchronous methods for
handling user-interface interaction. Interaction with the interface should not
be blocked needlessly.

Webservice interfaces need to be similarly responsive and not time out. Server
interfaces furthermore demands multi-threading and need to be able handle
multiple clients concurrently.


\section{Quality Assessment Criteria - Sustainability and Maintainability}

\subsection{Identity}

\indicator{ID1 -- Does the software provide a clear and unique identity?}

Software should be identifiable by a clear name that does not clash with others
in its application domain and in the wider generic software domain. An on-line
search of 

\indicator{ID2 -- Does the software have a website?}

The software should have a website that describes it, allows users to obtain
it as well as its documentation. The website should be a portal to everything
related to the software.

It is recommended to have a dedicated domain name or subdomain.

\indicator{ID3 -- The project name does not violate an existing trade-mark?}

The project name should not infringe on existing trade-marks.

\subsection{Copyright \& Licensing}

\indicator{CP1 -- Has an appropriate open-source licence been adopted?}

Software should be released as open source under an appropriate licence. The
licence should be recognised by the Open Source Initiative\footnote{https://opensource.org} or Free Software
Foundation\footnote{http://fsf.org}. Open source licences generally fall somewhere on a spectrum between the following two flavours:

\begin{itemize}
 \item Copyleft licence (GNU Public License (GPL) and variants): If the code is modified and distributed, the modified code must be distributed under the same licence. Also, if your code is licenced in this way and is used as a library or imported module by other software, then that software too is considered a derivate work and must be distributed under the same licence. This ensures that anybody derives a work from your code is obliged to distribute it as open source (free\footnote{Free as in free speech, not free beer} software) as well.
 \item Permissive licence (MIT, Apache Licence, BSD licence): Allows modifications and reuse with fewer restrictions. Generally anybody is free to use the code and use it in closed-source (non-free) software.
\end{itemize}

The decision which licence is most appropriate should be made on an individual
basis. Note that none of the major licences prohibits commercial use, nor is it
recommended to do so.

The licence chosen by the software may never not violate the licences of any of
the software's dependencies, if there are linking clauses in those. \footnote{This implies you that if you use GPL libraries, you can no longer release your software under a more permissive licence such as MIT}.

Any form of closed-source software is strongly discouraged as it is found to be
at odds with a scientific method that relies on methodological transparency,
reproducibility and peer review. The CLARIAH project is explicitly committed to
open source and ``aims to create an inclusive open-source engineering community
that will carry on providing new tools and support for users after the end of
the CLARIAH project'' \citep{CLARIAHTECHPLAN1}.


\indicator{CP2 -- Is it clear who wrote the software, who owns the
copyright, and what the licence is?}

Authors, copyright and licence should be clearly mentioned on the project
website, as well as in the source code.  We strongly recommend each source file
to contain a comment header stating this information.

\indicator{CP3 -- Are the funders acknowledged?}

Any external funders of the software should be publicly acknowledged on the project
website, and in the \texttt{README}.

\subsection{Accessibility}

\indicator{AC1 -- Is the source code maintained in a version control system?}

Source code must always be kept under version control. This enables developers
to collaborate, maintains a perfect version history, and allows everyone keep a
track of changes. Absence of version control is bad development practise and
unsustainable.

\indicator{AC2 -- Is the source code in a public version-controlled repository?}

The version control repository should be public (read only) in the spirit of both open
source, as well as the scientific method (transparency, peer review,
reproducibility). 

It is recommended to use a large sustainable third-party platform
(GitHub\footnote{\url{https://github.com}},
GitLab\footnote{\url{https://gitlab.com}},
BitBucket\footnote{\url{https://bitbucket.org}},
Launchpad\footnote{\url{https://launchpad.net}}), as it offers a social
dimension and is more likely to live beyond the lifetime of any current project
funding line. Use of sourceforge.net, de-facto standard prior to the advent of
current leader Github, is strongly discouraged as it is under ill management
and no longer deemed secure. Public repositories tend to be free on these platforms and
often come with many additional benefits, such as a good public issue tracker
(see SP2).

We motivate our reasoning in favour of public version control repositories as follows:

\begin{enumerate}
    \item increased visibility for the project, especially if a major external platform is used.
    \item facilitates judgement of development activity of a software project.
    \item facilitates collaboration, especially from external partners.
    \item invites peer review
    \item allows users to be more intimately aware of changes, which in an
        academic context may impact their experimental results.
\end{enumerate}

(depends on AC1)

\indicator{AC3 -- Is there no restricted data in the public source code repository?}

Privacy and security sensitive data (passwords, API keys), as well as other
restricted data, should never be checked into public version control systems.

\indicator{AC4 -- Are there clearly marked formal releases of software?}

The software should be formally released when the developers deem it a good
time. Each release should be clearly marked with the version number of the
software, according to a consistent scheme. The version control system should
also have clearly identifiable tags that mark the state of the repository at
the time of this release.


\indicator{AC5 -- Is the software deposited in a public repository for the language?}

The ecosystems surrounding various high-level programming languages offer
public repositories in which installable software release packages should be
deposited. These repositories function as a primary source for installation (see also
IS3) and generally offer automatic dependency management.

Use of these repositories is strongly recommended practise if available.

\begin{itemize}
    \item \textbf{Python} -- Releases of Python software should be deposited in
        the Python Package Index: \url{https://pypi.python.org}
    \item \textbf{Perl} --  Perl modules should be deposited in the Comprehensive
        Perl Archive Network (CPAN): \url{http://www.cpan.org}.
    \item \textbf{R} -- R packages should be deposited in the Comprehensive R
        Archive Network (CRAN): \url{https://cran.r-project.org}
    \item \textbf{Javascript} -- Javascript software should be deposited in
        NPM: \url{https://www.npmjs.com}
    \item \textbf{Ruby} -- Ruby software should be deposited to 
        RubyGems: \url{https://rubygems.org}
\end{itemize}

\indicator{AC6 - Is the software available in the target platform's software repository?}

If the software has a well-defined target platform and the target platform has
a public software repository available; then it is recommended to submit the
packages to this public repository.

This may however conflict with AC5, be rendered obsolete by AC5, or render AC5
obsolete. The decision which form of installation takes takes precendence should be
made on an individual basis, considering the nature and audience of the
software.

\begin{itemize}
    \item Linux/BSD/Unix -- Distributions generally have their own official repositories. Package inclusion can be a lengthy process.
    \begin{itemize}
        \item Arch Linux: Submit your package to the Arch User Repository\footnote{https://aur.archlinux.org} (AUR)
		\item CentOS: Consult https://wiki.centos.org/HowTos/Packages/ContributeYourRPMs
        \item Debian: Consult https://wiki.debian.org/Packaging
        \item Fedora: Consult https://fedoraproject.org/wiki/Packaging:Guidelines
        \item Ubuntu: Ubuntu inherits Debian's packages, therefore submitting Debian is recommended. Users can submit software submit software tol Package Archive (PPA).
    \end{itemize}
    \item Mac OS X: use the Apple Store for traditional Mac applications intended for end-users; for the more Unix-style
        software, use a system such as Homebrew or MacPorts.
    \item Android: use the Google Store, fully open-source software may also be submitted to F-Droid\footnote{https://f-droid.org}
    \item iOS: Use the Apple Store
    \item Windows: (TODO) 
\end{itemize}

It is not always time and cost effective to package and deposit the software,
especially not when there are multiple target platforms. When the software is
not intended for adoption by a wider audience, it can be considered to ignore
this guideline.

\indicator{AC7 -- Is each software release deposited in a persistent store with a unique DOI?}

Persistent stores aim to preserve research output. They aim for a longevity
that can not be guaranteed by normal software repositories. Each software
release should be deposited in a persistent store and receive a unique Digital
Object Identifier (DOI),  a persistent ID that is ubiquitous in the academic
world. The DOI can in turn be referenced in citations from publications.

Users using Github (see AC2) and Zenodo\footnote{\url{https://zenodo.org}, a
research data repository} can set this up with little effort. \footnote{A guide
for this is provided at https://guides.github.com/activities/citable-code/}.
Any releases made on GitHub will then automatically transfer to Zenodo and
receive a DOI, no user intervention is necessary. 

\subsection{Community}

This aspects related to what extent an active user community exists for the
software.

\indicator{CM1 - Is there evidence of the software being in use by others?}

It is recommended to list on the project website if the software has 
users aside from the primary developers and their immediate institution, this
may facilitate further adoption. It is also recommended to mention (on the
project website) a citable publication that discusses software, and to actively
recommend or even require others to cite this if they use the software.

A list of third-party publications citing the software is also recommended for
the project page. Alternatively, it is lightly recommended to
incorporate success stories or quotes from satisfied users on the project
website.

In addition to the aforementioned, evidence for this activity may also be sought
in contributions to the software by external developers (assuming
compliance with AC2), or questions in the issue/bug tracker or mailing lists.

\indicator{CM2 - Is there evidence of external developers?}

External developers, not related to the original developers or their
institution, are a good sign of community interest. The threshold for
contributing is relatively high. Compliance with this indicator is greatly
facilitated by compliance with AC2.

\indicator{CM3 - Are there statistics available on software use?}

To gain an impression of user interest, it is recommended to have statistics
available on how often the software is downloaded or how often the project page
is visited. Public availability of these statistics (stripped of any privacy
sensitive information), is recommended.

\subsection{Testability}

\indicator{TS1 -- Does the project have unit tests, is there sufficient coverage?}

Software should have unit tests that automatically test individual units of the
source code. They verify the data and logic flow by testing whether the output,
given certain input, confirms to expectation.

It is important that the tests cover enough of the source code, automated tools
and platforms are available that can help in this assessment, such as
\url{https://coveralls.io} and \url{https://codacy.com}.

\indicator{TS2 -- Does the project have integration tests, is there sufficient coverage?}

Software should have integration tests that combine invididual parts of modules and see how they function
as a group.

\indicator{TS3 -- Does the project have automated GUI tests?}

If the software offers a non-trivial GUI or WUI, it should have automated tests
that verify whether the interface functions as intended.

\indicator{TS4 -- Do tests are run automatically?}

It is recommended that test be run automatically, either through continuous
integration testing or periodically at a predefined interval. Free public
continuous integrations platforms such as
Travis-CI\footnote{https://travis-ci.org},
Gitlab-CI\footnote{https://gitlab.com},
Jenkins\footnote{https://jenkins-ci.org} can be hooked into version control
systems (see AC1, AC2) with minimal effort, resulting in an automatic run of the test suite
upon each commit and notifying the developer when the test suite fails.

It is strongly recommended that test results are publicly available, so users
can more quickly assess software quality.

\subsection{Portability}

Portability concerns the extent to which software can be used on multiple
platforms. 

\indicator{PB1 -- Is is clear for what platforms the software is written?}

It should be clear, from at least the project website, for what platforms the software
is intended.

\indicator{PB2 -- Is the software portable for multiple platforms?}

It is recommended to support a wide variety of platforms rather than a single
one. This, however, is not always feasible or cost and time effective.

\indicator{PB3 -- Does the software work on multiple browsers?}

This concerns only web-based software with a significant client-side component.
Such software should function under recent versions of all major browsers
(Mozilla Firefox, Google Chrome, Internet Explorer / Edge, Safari, Opera), and
never be limited to just one.

Moreover, it is recommended that such software does not rely on browser plugins that
are themselves not portable. Adobe Flash or Microsoft Silverlight are two
examples of badly portable legacy technologies that should be avoided, always use
modern substitutes (HTML5) instead.

\subsection{Supportability}

To what extent will the product be supported currently and in the future?

\indicator{SP1 -- Is it clear whom to contact for support?}

It should be clear where to go for support. A project must have a contact
e-mail address. If an issue tracker is present (SP2), it should be clearly advertised
as well.

\indicator{SP2 -- Is there a public issue tracker?}

A public issue/bug tracker is strongly recommended. It allows everyone to post
bugs or features requests and allows users to see what issues are current, how
they are resolved, and if they are resolved in a timely fashion. It also
prevents helps to prevent duplication of issues, and gives a platform for
tracking feature requests.

\indicator{SP3 -- Is there a mailing list?}

Projects with a fair amount of activity benefit from having a mailing list. It
can function as a lesser substitute of SP2 (SP2 therefore may make this
obsolete), but can also serve as an extra line of communications between users
and developers. The mailing list must allow anyone to subscribe and must have a
public archive allowing users to follow any issues and follow development.

\subsection{Analysability}

This section concerns the extent to which the source code can be understood. At
this level, the source code is inspected in closer detail.

\indicator{AN1 -- Is the source code structured adequately?}

Source code should be modular, i.e. it should be structured into multiple
modules/packages, following the requirements and conventions of the programming
language. 

The structure of the source code should bear a clear relationship to the
architecture or design of the software.

(See also R3)

\indicator{AN2 -- Is the source code commented adequately?}

The source code should contain comments explaining what major blocks do.

\indicator{AN3 -- Do the comments generate API documentation?}

The comments use a mark-up that allows them to be used directly as the
source for the generation of the API reference documentation. This is
accomplished using document generation tools such as Doxygen\footnote{\url{http://www.doxygen.org}}, Sphinx\footnote{\url{http://www.sphinx-doc.org}} or
Javadoc\footnote{\url{http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html}}.

\indicator{AN4 -- Is the source code cleanly laid out?}

The source code should follow a proper indentation convention. 

\indicator{AN5 -- Are sensible names used?}

Do the classes, functions and variables in the source code use sensible names
and do they follow a consistent naming scheme that is conventional for the
programming language?

\indicator{AN6 -- Are there no blocks of commented out code or obsolete files?}

There should be no large block of commented-out code, nor obsolete files.
(this depends on compliance with AC1)

\indicator{AN7 -- Are all TODO comments resolved?}

There should be no important TODO comments, if there are they should at least be
clearly described in the issue tracker (SUP2).

\indicator{AN8 -- Does the project have recommended coding standards?}

A project should have recommended coding standards to which contributors
should adhere. These standards should be consistent with the larger community
of generic coding standards for the programming language.

\subsection{Changeability}

\indicator{CH1 -- Is the project open to contributions from third parties?}

A project is recommended to be open to outside contributions. Community
involvement is a major factor in the success of a software project. 

This depends on AC1, AC2, and facilitates COM1 and COM2. 

\indicator{CH2 -- Does the project have guidelines for contributions?}

If contributions are desired, a project is recommended to have guidelines for
contributors. These must be publicly available.
See also AN8.

\indicator{CH3 -- Are all source code changes, and their authorship, publicly visible?} 

Collaboration requires awareness of what changes, when it changes, and who
changes it. This depends on AC1, heavily facilitated by AC2.

Alternatively, commits messages can be forwarded to mailing lists, Slack, IRC chat, or
whatever is deemed appropriate.

\indicator{CH4 -- Is the software sufficiently backwards-compatible?}

Software should be backwards compatible with old versions of itself with respect
to public interfaces and data input. Backward-compatibility changes and
deprecation may occur but should always be clearly announced ahead of time.

\indicator{CH5 -- Is there a roadmap for future changes?}

Software still under active development should have roadmap. This may take
shape either as an explicit roadmap or implicit in the issue tracker
(SUP2) through the assignment of milestones.

\indicator{CH6 -- Does the website mention how the software is funded and
when funding ends?}

\subsection{Reusability}

\indicator{R1 -- Does the software support multiple interfaces?}

The use of multiple interfaces enables reusability. Different users should be
able to access the software at different levels. End-users usually require a
GUI or WUI, developer-users prefer a command line interface (CLI) and/or
webservice interface, developers needs a software library with API.

Assessment of this depends greatly on the intended audience of the software (see U2).

\indicator{R2 -- Is the software modular, can the software support multiple interfaces?}

Software should be set up in such a manner that higher-level interfaces can be
constructed on its lower-level components. This implies that there should be a
clear separation between front-end and back-end. In order to achieve this it we
strongly recommend software to be set up in a modular fashion, allowing reuse
of its components without the need to modify these components.

Modularity can be expressed as layers, from low-level to high-level:

\begin{itemize}
 \item Classes and functions are defined at the source code level. (see R3)
 \item Libraries group and expose these publicly, described by APIs. 
 \item Command Line Interfaces use the libraries.
 \item Servers/daemons use the libraries, networked clients use the server/daemons.
 \item GUIs and WUIs use either the libraries, the CLI tools, or act as a networked client to the servers/daemons.
\end{itemize}

Whenever two or more of these layers are intrinsically merged, reusability potential is lost.
For instance, monolithic software that offers only a GUI interface can not be
readily adapted to add a CLI or web interface.

Maximum reusability is not always desired or time and cost effective. The
desired degree of of modularity and reusability is to be assessed on an
individual basis.

\indicator{R3 -- Is the software's source code set-up in a modular fashion?}

The software's source code should define clearly delimited classes and
functions, following the paradigm of the programming language. 

(See also AN1)


\subsection{Interoperability}

\indicator{IP1 -- Does the software use appropriate open standards for data?}

Software should adhere to appropriate open standards as much as possible, i.e.
it should be able to read input files and write output files in open
standards. Support of multiple open standards is recommended. Conversion may
also be mediated through other third party tools.

\subsection{Interoperability for CLARIAH}

(TODO)

\subsection{Security \& Privacy}

\indicator{SC1 -- Is the software free of obvious security flaws?}

Software should be secure and have no holes that allow unauthorised users to
gain access. Developers should take care to avoid common attack vectors such as
shell injection, SQL injection, cross-site request forgery, buffer overflow.
Proper validation of user input is a major factor in preventing security holes

Assessment of security is an art in itself and non-trivial. 

\indicator{SC2 -- Is user privacy secured effectively?}

Privacy-sensitive user data must be treated with care. Passwords must never be
stored in unhashed form, private keys must never be shared. Strongly related to
SEC1. Also see AC3.


\section{Quality Measurement}

To achieve a measure of quality, evaluators can compute a quality score ($Q$,
expressed as a percentage) per criterion, by counting how many of the
indicators are answered with ``yes'' ($p$), and how many with ``no`` ($n$),
following the simple formula in Equation~\ref{eq1}.

\begin{equation}
\label{eq1}
Q = (p / (p + n)) \cdot 100
\end{equation}

A passing threshold can be defined, either on a per-criterion basis or just
by applying the same threshold for all. 

(TODO: section not finished)


\bibliographystyle{plainnat}
\bibliography{softwareguidelines}

\end{document}
