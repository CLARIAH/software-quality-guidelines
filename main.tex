\documentclass[a4paper,11pt]{article}
\usepackage[english]{babel}
\usepackage{hyperref}{}

\begin{document}

\title{Guidelines for Software Quality}
\subtitle{CLARIAH Task 54.100} 

\author{Maarten van Gompel}

\maketitle

\section{Introduction}

CLARIAH aims to deliver a digital research infrastructure made explicitly
accessible for researchers from the humanities. This makes the development of advanced ICT
tools a core activity within CLARIAH. To be able assess the
quality of the research infrastructure as a whole, we need to be able to assess
the quality of its individual software and data components. If we can establish
a common set of software guidelines, we may more readily identify weaker
components of the software infrastructure and work on their improvement.
Assessing software or data quality, however, is not a trivial matter. 

Whenever we refer to \emph{software}, we intend the term in a broad sense and
encompassing all of the following aspects:
\begin{itemize}
    \item source code
    \item binary executables
    \item user interfaces (including application programming interfaces (APIs) and web APIs)
    \item associated essential data
    \item documentation (including tutorials, screencasts)
    \item support infrastructure (version control, build systems, issue trackers)
\end{itemize}

The guidelines for software quality will be formulated as a series of
assessment criteria, posed as questions, divided over several categories. This
makes them directly applicable as an instrument for software quality
assessment. These guidelines target developers, managers and users of software.
Developers will be more aware of the targets to meet, and able to identify and
remedy weak areas. Managers and users will be able to assess whether software is of
sufficient enough quality for their purposes. Although we intend to formulate
the questions as plainly as possible, a certain degree of technical
expertise is demanded of all of these in otder to attain a successful
assessment.

Each question, if applicable, should be answered affirmatively. This will lead
to measurable quality levels. Full compliance with the guidelines is achieved
when all questions are answered affirmatively. In practise, however, this is
not realistic to happen. Evaluators will need to determined for themselves what
compliance level, per category, constitutes an acceptable passing threshold.

The criteria we yield, and their categories, are derived to large extent from
the \emph{criteria-based software evaluation guide} \cite{SSIGUIDE} by the Software
Sustainability Institute (SSI). Their work, in turn, is modelled after \emph{ISO/IEC
9126-1 Software Engineering - Product Quality}.  The Software
Sustainability Institute is an academic institute explicitly geared towards
researchers and software developers in science, and as-such its work is of
great relevance to projects such as CLARIAH. 

The SSI, following ISO 9126-1, has grouped assessment criteria as follows
\cite{SSIGUIDE}.

\begin{tabular}{|l|l|}
\textbf{Usability} \\
Understandability & Is the software easily understood? \\ 
Documentation & Comprehensive well-structured documentation? \\
Buildability  & Straightforward to build from source on a supported system? \\
Installability  & Straightforward to install and deploy on a supported system? \\
Learnability & Easy/intuitive to learn how to use its functions? \\
\hline
\textbf{Sustainability \& Manageability}
Identity & Project/software identity is clear and unique? \\
Copyright & Easy to see who owns the project/software? \\
Licencing & Adoption of appropriate licence?
Governance & Easy to understand how the project is run and the development managed? \\
Community & Evidence of current/future community? \\
Accessibility & Evidence of good facilities to obtain versions of the software? \\
Testability & Easy to verify if the software functions correctly? \\
Portability & Usable on multiple platforms? \\
Supportability & Evidence of current/future developer support? \\
Analysability & Easy to understand at the source-code level? \\
Changeability & Easy to modify and contribute changes? \\
Evolvability & Evidence of current/future development? \\
Interoperability & Interoperable with other required/related software? \\
\end{tabular}

The next section will list all assessment criteria. %TODO: say something about difference  with SSI

\section{Quality Assessment Criteria - Usability}

\subsection{Understandability}

\subsubsection{U1 -- Is it clear what the software does?}

Software must be accompanied be a clear high-level description, describing what
exactly it does. Both the README file that ships with the software as well as
the project website should contain this information. 

\subsubsection{U2 -- Is it clear for whom the software is intended?}

It should be clear who are the intended users for the software. Software is
usually not appropriate for all audiences. Gearing software at multiple
audiences however, through for instance offering multiple interfaces (command
line, GUI, webservice) is good practise. References to projects already using the
software are suggested.

\subsubsection{U3 -- Is it clear how the software works?}

There should be a high-level description explaining how the software
accomplishes its task. Links to publications are recommended. Also, a schema
offering an architectural overview is suggested where appropriate. 

\subsubsection{U4 -- Is the software motivated?}

There should be a written motivation for why the software does things the way
it does and why it was designed in the first place. It should be clear what
problems are solved by it. Links to publications are suggested.

\subsection{Documentation}

When we refer to documentation, we refer to the set of all documentation
available for the software. This may consists of different types of
documentation for different audiences, and may include academic papers.

\subsubsection{DOC1 -- Is there documentation?}

All software should be properly documented. Software without any documentation
is as good as useless. At the very least, documentation at a minimum level
must be available. 

\subsubsection{DOC2 -- Is the documentation accessible?}

Documentation must be publicly accessible and in an acceptable standard format
such as HTML or PDF.

\subsubsection{DOC3 -- Is the documentation clear?}

Is it clear enough? Does it clearly describe the software. Step-by-step
and task-oriented instructions are recommended.

\subsubsection{DOC4 -- Is the documentation complete?}

Documentation should cover the entire software, including advanced features.

\subsubsection{DOC5 -- Is the documentation accurate?}

Documentation should describe the advertised version and not be out-of-date
with the latest release. Example should be in line with how the tool looks and
behaves.

\subsubsection{DOC6 -- Does the documentation provide a high-level overview of the software?}

Documentation should offer a high-level overview of the software, rather
than immediately dive into the details.

\subsubsection{DOC7 -- Does the address the necessary audiences, at their appropriate levels?}

Different groups of users require different documentation. Developers require
APIs if the software is a library, end-users require a walkthrough of the GUI
if the software has one. A different level of expertise may be expected of
different user groups, the documentation should assume the appropriate level.

\subsubsection{DOC8 -- Does the documentation make use of adequate examples?}

Documentation should contain examples appropriate for the interface that is
described. Command-line interfaces should see examples of invocation and input
and output. Graphical user interfaces should be illustrated through screenshots or
screencasts. API references should contain source code examples of usage.

\subsubsection{DOC9 -- Is there adequate troubleshooting information?}

Documentation should include information on troubleshooting, i.e.\ a
specification of possible error messages and explanation for resolution.

\subsubsection{DOC10 -- Is the documentation available from the project website?}

Documentation must be clearly linked from the project website.

\subsubsection{DOC11 -- Is the documentation under version control?}

The sources for documentation must be under version control like the source
code, preferably alongside the code itself.

\subsection{Learnability}

This category partially overlaps with the documentation category, but explicitly
focusses on how straightforward it is to learn to use the sofware.

\subsubsection{LRN1 -- Is there a getting started guide?}

A getting started guide outlines how to quickly get started with the software
using a basic example.

\subsubsection{LRN2 -- Are there instructions for basic use cases?}

Instructions should be provided for at least basic use cases, and ideally for
all possible use cases.

\subsubsection{LRN3 -- Does the interface provide a help reference?}

Help options should be provided by the interface. Command line interfaces must
have a -h/--help pair describing usage and all options. GUIs should use tooltips/hints to clarify
their widgets (or through whatever convention is customary for the
platform/ecosystem). Alternatively, they can provide a help option referring to
the documentation.

\subsubsection{LRN4 -- Is there API documentation for developers?}

If the software is a programming library. API documentation must be provided.
If the software is a webservice, a specification of the web API must be provided.

\subsubsection{LRN5 -- If the software is configurable, are the configuration
options clearly explained?}


\subsection{Buildability}

Buildability applies to all software written in languages that compile to
either native machine code or any intermediate byte code to be interpeted by a VM.
This is contrasted to software that is interpreted at run-time from source
code. This section is therefore applicable only to languages such as C, C++,
Java, Pascal, Haskell, Scala, Rust, Cython but not to scripting language such
as Python, Ruby, Perl, Go.  Note that buildability does not include
installation, packaging, or deployment.

\subsubsection{BLD1 -- Are there good instructions for building/compiling the software?}

Build/compilation instruction should be available and clear enough. They should
be distributed alongside the software's source distribution (as part of an
INSTALL file or README), and/or be addressed in the documentation. If the
source distribution is the primary means of distribution, then build
instructions should be prominently displayed on the project website as well.

\subsubsection{BLD2 -- Is an established automated build system used?}

Established build systems should be used. For example the GNU Build
System\footnote{also known as the autotools} or CMake for C/C++ (this is
preferred over a static Makefile); or Ant or Maven for Java. 

Solutions that are not tied to a single IDE are always preferred.

\subsubsection{BLD3 -- Are all dependencies listed and available?}
(related to IS2)

All required or optional dependencies should be listed, including those by
third parties (with references to their websites). If the build system supports
automatically obtaining dependencies, then this is a preferred solution. If the
platform has a package manager that can install these dependencies, then add
instructions (i.e. package names) to accomplish this.

Moreover, all listed dependencies should be available, unobtainable software
can not be used as a dependency. Higher-order dependencies need not be listed.

\subsubsection{BLD4 -- Are there tests to verify the build has succeeded?}


\subsection{Installability}

Installability concerns the deployment of software on the target platform, also
including configuration of the software to the user's needs.

\subsubsection{IS1 -- Are there easily accessible installation instructions?}

All software must come with installation instructions. Those instructions should
be easily accessible and presented on the project website as well as shipped
with the software in the README or INSTALL file. Build and installation
instructions can be combined if the software is published as a source
distribution.

\subsubsection{IS2 -- Are all dependencies listed and available?}
(related to BLD3)

All required or optional dependencies should be listed, including those by
third parties (with references to their websites). If the installation
procedure supports automatically obtaining dependencies, then this is a
preferred solution (see also IS3). If the platform has a package manager that
can install these dependencies, then add instructions (i.e. package names) to
accomplish this.

Moreover, all listed dependencies should be available, unobtainable software
can not be used as a dependency. Higher-order dependencies need not be listed.

\subsubsection{IS3 -- Does the installation procedure comply to best practises
in the ecosystem around the programming language?}

The ecosystem surrounding programming languages may come with standard
procedures for installation. Software should comply to these rather than use
ad-hoc mechanisms. If the ecosystem has facilities for dependency management
(automatic download of dependencies), these should be used.

\begin{itemize}
 \item Python software should have a \texttt{setup.py} based on Distutils,
     Setuptools, or their relatives.
 \item Installation of C/C++ software is generally an extension of the build
     process, often culminating in a \texttt{make install}.
 \item TODO: Java, R ?
\end{itemize}

\subsubsection{IS4 -- Is the software packaged according to standards for the target platform?}

If the sofware has a well-defined target platform and is intended for adoption
by a wider audicence, it is recommended to package it in the appropriate form.
This may however conflict with IS3, be rendered obsolete by IS3, or render IS3
obsolete. The decision form of installation takes takes precendence should be
made on an individual basis, considering the nature and audience of the
software.

\begin{itemize}
    \item Linux/BSD/Unix -- Distributions generally have their own package manager
    \begin{itemize}
        \item Arch Linux: Use the Arch User Repository (AUR)
        \item Debian/Ubuntu (and other derivates): Use Debian Packages (deb)
        \item RedHat/CentOS/Fedora (and other derivates): Use Red Hat Packages (rpm)
    \end{itemize}
    \item Mac OS X: Use PKG or DMG for traditional Mac applications intended for end-users; for the more Unix-style
        software, use a system such as Homebrew or MacPorts
    \item Android: Use Android Application Packages (APK)
    \item iOS: (TODO) 
    \item Windows: (TODO) 
\end{itemize}

It is not always time and cost effective to package the sofware, especially not
when there are multiple target platforms. 

\subsubsection{IS5 -- Is the software package properly structured?}

If software is distributed as a plain archive (tar.gz, tar.bz2, zip or otherwise),
it must create a single directory when unpacked rather than spread its contents
over the current working directory.

The contents of the archive should be properly organised in sub-directories
(for documentation, headers, source, etc..). Conventions may differ between
programming languages.

\subsubsection{IS6 -- Is the software properly structured when installed?}

If the software is installed, it should adhere to file placement standards set
by the target platform. On Unix-like operating systems (excluding Mac OS X), the Filesystem
Hierarchy Standard (FHS) should be followed.

\subsubsection{IS7 -- The software must included a README}

The README must contain links to the project website, as well as licence and copyright
information.

\subsubsection{IS8 -- There must be facilities to uninstall the software}

This is usually trivial when the software complies to IS4 and/or IS3, or if the
software installation is self-contained in a single directory. In all other
instances, proper uninstallation procedures should be in place.


\section{Quality Assessment Criteria - Sustainability and Maintainability}

\subsection{Identity}

\subsubsection{ID1 - Does the software provide a clear and unique identity?}

Software should be identifiable by a clear name that does not clash with others
in its application domain and in the wider generic software domain. An on-line
search of 

\subsubsection{ID2 - Does the software have a website?}

The software should have a website that describes it, allows users to obtain
it as well as its documentation. The website should be offer a portal to everything
related to the sofware.

It is recommended to have a dedicated domain name or subdomain.

\subsubsection{ID3 - The project name does not violate an existing trade-mark?}

\subsection{Copyright \& Licensing}

\subsubsection{CP1 - Has an appropriate open-source licence been adopted?}

Software should be released as open source under an appropriate licence. The
licence should be recognised by the Open Source Initiative or Free Software
Foundation.

The licence may never not violate the licences of any of the software's
dependencies, if their are linking clauses in those.

Any form of closed-source software is strongly discouraged and not deemed
compatible with the scientific method that demands methodological transparency,
reproducibility and peer review.

\subsubsection{CP2 - Is it clear who wrote the software, who owns the
copyright, and what the licence is?}

Authors, copyright and licence should be clearly mentioned on the project
website, as well as in the source code.  We strongly recommend each source file
to contain a comment header stating this information.

\subsubsection{CP3 - Are the funders acknowledged?}

The funders of the software should be publically acknowledged on the project
website, and in the README.

\subsection{Community}

This aspects related to what extent and active user community exists for the
software.


\subsection{Accessibility}

\subsubsection{AC1 -- Is the source code maintained in a version control system?}

Source code must always be kept under version control to enable developers to
collaborate and keep a track of changes. Absence of version control is bad
development practise. 

\subsubsection{AC2 -- Is the source code in a public version-controlled repository?}

The version control repository should be public (read only) in the spirit of both open
source, as well as the scientific method (transparency, peer review,
reproducibility). 

It is recommended to use a large sustainable third-party platform (GitHub,
GitLab, BitBucket, Launchpad), as it offers a social dimensions and is more
likely to live beyond the lifetime of any current project funding line.

We motivate our reasoning in favour of public version control repositories as follows:

\begin{enumerate}
    \item Increased visibility for the project, especially if a major external platform is used.
    \item facilitates judgement of development activity of a software project.
    \item facilitates collaboration, especially from external partners.
    \item invites peer review
    \item allows users to be more intimately aware of changes, which in an
        academic context may impact their experimental results.
\end{enumerate}

\subsubsection{AC3 -- Is there no restricted data in the public source code repository?}

Privacy and security sensitive data (passwords, API keys), as well as other
restricted data, should never be checked into public version control systems.

\subsubsection{AC4 -- Are their clearly marked formal releases of the source code?}

The source code of the software should be released, and each release should
clearly marked with the version number of the software. The version control
system should also have clearly identifiable tags that mark the state of the
repository at the time of this release.

We recommend that each source code release is also transferred to a persistant
store and receives a DOI.

\subsubsection{AC5 -- Are software releases deposited in a public
    repository pertaining to the ecosystem surrounding the programming
language?}

The ecosystems surrounding various high-level programming languages offer
public repositories in which installable software release packages should be
deposited. These repositories function as a primary source for installation (see also
IS3) and generally offer automatic dependency management.

Use of these repositories is recommended practise if available.

\begin{itemize}
    \item \textbf{Python} -- Releases of Python software should be deposited in
        the Python Package Index: \url{https://pypi.python.org}
    \item \textbf{Perl} --  Perl modules should be deposited in the Comprehensive
        Perl Archive Network (CPAN): \url{http://www.cpan.org}.
    \item \textbf{R} -- R packages should be deposited in the Comprehensive R
        Archive Network (CRAN): https://cran.r-project.org
    \item \textbf{Javascript} -- Javascript software should be deposited in
        NPM: https://www.npmjs.com
\end{itemize}

\subsubsection{AC6 - Is the software available in the target platform's software repository?}

If the sofware has a well-defined target platform and the target platform has a
public software repository available, and the software is intended for adoption by a
wider audience; then it is recommended to submit the packages to this public
repository.

This may however conflict with AC5, be rendered obsolete by AC5, or render AC5
obsolete. The decision which form of installation takes takes precendence should be
made on an individual basis, considering the nature and audience of the
software.

\begin{itemize}
    \item Linux/BSD/Unix -- Distributions generally have their repositories
    \begin{itemize}
        \item Arch Linux: Submit your package to the Arch User Repository (AUR)
        \item Debian: Submit your package to Debian
        \item Ubuntu: Ubuntu inherits Debian's packages, therefore submitting Debian is recommended.
        \item RedHat/CentOS/Fedora (and other derivates): Use Red Hat Packages (rpm)
    \end{itemize}
    \item Mac OS X: Use the Apple Store for traditional Mac applications intended for end-users; for the more Unix-style
        software, use a system such as Homebrew or MacPorts.
    \item Android: use the Google Store, fully open-source software may also be
        submitted to F-Droid
    \item iOS: Use the Apple Store
    \item Windows: (TODO) 
\end{itemize}

It is not always time and cost effective to package and deposit the sofware, especially not
when there are multiple target platforms. 




























\end{document}
